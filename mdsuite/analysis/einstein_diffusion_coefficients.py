"""
Class for the calculation of the einstein diffusion coefficients.

Author: Samuel Tovey

Description: This module contains the code for the Einstein diffusion coefficient class. This class is called by the
Experiment class and instantiated when the user calls the Experiment.einstein_diffusion_coefficients method.
The methods in class can then be called by the Experiment.einstein_diffusion_coefficients method and all necessary
calculations performed.
"""

# Python standard packages
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
import numpy as np
import warnings
import tensorflow as tf

# Import user packages
from tqdm import tqdm

# Import MDSuite packages
import mdsuite.utils.meta_functions as meta_functions
from mdsuite.analysis.analysis import Analysis

# Set style preferences, turn off warning, and suppress the duplication of loading bars.
plt.style.use('bmh')
tqdm.monitor_interval = 0
warnings.filterwarnings("ignore")


class EinsteinDiffusionCoefficients(Analysis):
    """ Class for the Einstein diffusion coefficient implementation

    Attributes
    ----------
    plot : bool
    singular : bool
    distinct : bool
    species : list
    data_range : int
    """

    def __init__(self, obj, plot=True, singular=True, distinct=False, species=None, data_range=200, save=True,
                 x_label='Time (s)', y_label='MSD (m^2/s)', analysis_name='einstein_diffusion_coefficients'):
        """ Python constructor """

        super().__init__(obj, plot, save, data_range, x_label, y_label, analysis_name)  # parse to the parent class

        self.loaded_property = 'Unwrapped_Positions'
        self.batch_loop = None

        self.singular = singular
        self.distinct = distinct
        self.species = species

        self.time = np.linspace(0.0, self.data_range * self.parent.time_step * self.parent.sample_rate, self.data_range)
        self.correlation_time = 100

    def _autocorrelation_time(self):
        """ Calculate positions autocorrelation time

        When performing this analysis, the sampling should occur over the autocorrelation time of the positions in the
        system. This method will calculate what this time is and sample over it to ensure uncorrelated samples.
        """
        pass

    def _calculate_batch_loop(self):
        """ Calculate the batch loop parameters """
        self.batch_loop = int((self.batch_size['Serial'] * self.data_range) / (self.data_range + self.correlation_time))

    def _load_batch(self, batch_number, item=None):
        """ Load a batch of data """
        start = batch_number*self.batch_size['Serial']*self.data_range
        stop = start + self.batch_size['Serial']*self.data_range

        return self.parent.load_matrix("Unwrapped_Positions", item, select_slice=np.s_[:, start:stop], tensor=True)

    def _single_diffusion_coefficients(self):
        """ Calculate singular diffusion coefficients

        Implement the Einstein method for the calculation of the singular diffusion coefficient. This is performed
        using unwrapped coordinates, generated by the unwrap method. From these values, the mean square displacement
        of each atom is calculated and averaged over all the atoms in the system.
        """

        # Loop over each atomic species to calculate self-diffusion
        for item in list(self.species):
            msd_array = np.zeros(self.data_range)  # define empty msd array

            # Calculate the prefactor
            numerator = self.parent.units['length'] ** 2
            denominator = (self.parent.units['time'] * len(self.parent.species[item]['indices'])) * 6
            prefactor = numerator / denominator

            # Construct the MSD function
            for i in tqdm(range(int(self.n_batches['Serial'])), ncols=70):
                batch = self._load_batch(i, [item])  # load a batch of data
                for start_index in range(self.batch_loop):
                    start = start_index*self.data_range + self.correlation_time
                    stop = start + self.data_range
                    window_tensor = batch[:, start:stop]

                    # Calculate the msd
                    msd = (window_tensor - (
                        tf.repeat(tf.expand_dims(window_tensor[:, 0], 1), self.data_range, axis=1))) ** 2

                    # Sum over trajectory and then coordinates and apply averaging and prefactors
                    msd = prefactor * tf.reduce_sum(tf.reduce_sum(msd, axis=0), axis=1)
                    msd_array += np.array(msd)  # Update the averaged function

            msd_array /= int(self.n_batches['Serial'])*self.batch_loop  # Apply the batch/loop average

            popt, pcov = curve_fit(meta_functions.linear_fitting_function, self.time, msd_array)
            self.parent.diffusion_coefficients["Einstein"]["Singular"][item] = [popt[0], np.square(np.diag(pcov))[0]]

            # Update the plot if required
            if self.plot:
                plt.plot(np.array(self.time) * self.parent.units['time'], msd_array, label=item)

            # Save the array if required
            if self.save:
                self._save_data(f"{item}_{self.analysis_name}", [self.time, msd_array])

        # Save a figure if required
        if self.plot:
            self._plot_data()

    def _distinct_diffusion_coefficients(self):
        """ Calculate the Distinct Diffusion Coefficients

        Use the Einstein method to calculate the distinct diffusion coefficients of the system from the mean
        square displacement, as calculated from different atoms. This value is averaged over all the possible
        combinations of atoms for the best fit.
        """
        """
        positions_matrix = self.load_matrix("Velocities")

        combinations = ['-'.join(tup) for tup in
                        list(itertools.combinations_with_replacement(list(self.species.keys()), 2))]

        index_list = [i for i in range(len(positions_matrix))]
        time = np.linspace(0.0, data_range * self.time_step * self.sample_rate, data_range)

        used_configurations = int(self.number_of_configurations - self.number_of_configurations % self.batch_size)

        # Update the dictionary with relevant combinations
        for combination in combinations:
            self.diffusion_coefficients["Einstein"]["Distinct"][combination] = {}
        pairs = 0

        for tuples in itertools.combinations_with_replacement(index_list, 2):
            msd = [[np.zeros(used_configurations)],
                   [np.zeros(used_configurations)],
                   [np.zeros(used_configurations)]]
            numerator = self.length_unit ** 2 * self.number_of_atoms
            denominator = len(positions_matrix[tuples[0]]) * len(positions_matrix[tuples[1]]) * 6 * self.time_unit

            for i in range(len(positions_matrix[]))
        """
        raise NotImplementedError

    def run_analysis(self):
        """ Run a diffusion coefficient analysis

        In order to full calculate diffusion coefficients from a simulation, one should perform a two-stage error
        analysis on the data. The two steps are performed at the same time. The first error contribution comes from
        the fit error of the scipy fit package. The second is calculated by averaging the diffusion coefficient
        calculated at start times, taken over correlation times.
        """

        self._autocorrelation_time()                    # get the autocorrelation time
        self._collect_machine_properties()              # collect machine properties and determine batch size
        self._calculate_batch_loop()                    # Update the batch loop attribute
        if self.singular:
            self._single_diffusion_coefficients()       # calculate the singular diffusion coefficients
        if self.distinct:
            self._distinct_diffusion_coefficients()     # calculate the distinct diffusion coefficients
