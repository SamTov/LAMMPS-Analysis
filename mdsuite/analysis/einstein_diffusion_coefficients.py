"""
Class for the calculation of the einstein diffusion coefficients.

Author: Samuel Tovey

Description: This module contains the code for the Einstein diffusion coefficient class. This class is called by the
Experiment class and instantiated when the user calls the Experiment.einstein_diffusion_coefficients method.
The methods in class can then be called by the Experiment.einstein_diffusion_coefficients method and all necessary
calculations performed.
"""

# Python standard packages
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
import numpy as np
import warnings
import tensorflow as tf

# Import user packages
from tqdm import tqdm

# Import MDSuite packages
import mdsuite.utils.meta_functions as meta_functions

# Set style preferences, turn off warning, and suppress the duplication of loading bars.
plt.style.use('bmh')
tqdm.monitor_interval = 0
warnings.filterwarnings("ignore")


class _EinsteinDiffusionCoefficients:
    """ Class for the Einstein diffusion coefficient implementation

    additional attrbs:
        plot
        singular
        distinct
        species
        data_range
    """

    def __init__(self, obj, plot=False, singular=True, distinct=False, species=None, data_range=500):
        self.parent = obj
        self.plot = plot
        self.singular = singular
        self.distinct = distinct
        self.species = species
        self.data_range = data_range
        self.time = self.time = np.linspace(0.0, self.data_range * self.parent.time_step * self.parent.sample_rate,
                                            self.data_range)

    def _autocorrelation_time(self):
        """ Calculate postions autocorrelation time

        When performing this analysis, the sampling should occur over the autocorrelation time of the positions in the
        system. This method will calculate what this time is and sample over it to ensure uncorrelated samples.
        """
        pass

    def _single_diffusion_coefficients(self):
        """ Calculate singular diffusion coefficients

        Implement the Einstein method for the calculation of the singular diffusion coefficient. This is performed
        using unwrapped coordinates, generated by the unwrap method. From these values, the mean square displacement
        of each atom is calculated and averaged over all the atoms in the system.
        """

        # Loop over each atomic species to calculate self-diffusion
        for item in list(self.species):
            positions_tensor = tf.convert_to_tensor(np.array(self.parent.load_matrix("Unwrapped_Positions",
                                                                                 [item]))[:, 0:self.data_range])

            # Calculate the prefactor
            numerator = self.parent.units['length'] ** 2
            denominator = (self.parent.units['time']*len(self.parent.species[item]['indices'])) * 6
            prefactor = numerator / denominator

            # Calculate the msd
            msd = (positions_tensor - (tf.repeat(tf.expand_dims(positions_tensor[:, 0], 1), self.data_range, axis=1))) ** 2
            msd = prefactor * tf.reduce_sum(tf.reduce_sum(msd, axis=0), axis=1)  # Sum over trajectory and then coordinates

            if self.plot:
                plt.plot(self.time, msd, label=item)

            popt, pcov = curve_fit(meta_functions.linear_fitting_function, self.time, msd)
            self.parent.diffusion_coefficients["Einstein"]["Singular"][item] = popt[0]

        if self.plot:
            plt.xlabel("Time (s)")
            plt.ylabel(r"MSD ($m^2$)")
            plt.legend()
            # plt.savefig(f"self.cwd/Images/einstein_diffusion_coefficients.eps", format='eps')
            plt.show()

    @staticmethod
    def _distinct_diffusion_coefficients():
        """ Calculate the Distinct Diffusion Coefficients

        Use the Einstein method to calculate the distinct diffusion coefficients of the system from the mean
        square displacement, as calculated from different atoms. This value is averaged over all the possible
        combinations of atoms for the best fit.
        """
        """
        positions_matrix = self.load_matrix("Velocities")

        combinations = ['-'.join(tup) for tup in
                        list(itertools.combinations_with_replacement(list(self.species.keys()), 2))]

        index_list = [i for i in range(len(positions_matrix))]
        time = np.linspace(0.0, data_range * self.time_step * self.sample_rate, data_range)

        used_configurations = int(self.number_of_configurations - self.number_of_configurations % self.batch_size)

        # Update the dictionary with relevant combinations
        for combination in combinations:
            self.diffusion_coefficients["Einstein"]["Distinct"][combination] = {}
        pairs = 0

        for tuples in itertools.combinations_with_replacement(index_list, 2):
            msd = [[np.zeros(used_configurations)],
                   [np.zeros(used_configurations)],
                   [np.zeros(used_configurations)]]
            numerator = self.length_unit ** 2 * self.number_of_atoms
            denominator = len(positions_matrix[tuples[0]]) * len(positions_matrix[tuples[1]]) * 6 * self.time_unit

            for i in range(len(positions_matrix[]))
        """
        return

    def _run_analysis(self):
        """ Run a diffusion coefficient analysis

        In order to full calculate diffusion coefficients from a simulation, one should perform a two-stage error
        analysis on the data. The two steps are performed at the same time. The first error contribution comes from
        the fit error of the scipy fit package. The second is calculated by averaging the diffusion coefficient
        calculated at start times, taken over correlation times.
        """
        pass
